% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gap_detection.R
\name{detect_morphospace_gaps}
\alias{detect_morphospace_gaps}
\title{Detect Morphospace Gaps with Uncertainty Quantification}
\usage{
detect_morphospace_gaps(
  pca_scores,
  uncertainty = 0.05,
  grid_resolution = 150,
  monte_carlo_iterations = 100,
  monte_carlo_iterations_bootstrap = NULL,
  bootstrap_iterations = 200,
  bootstrap_sample_size = NULL,
  bootstrap_progress_every = 100,
  group_column = NULL,
  groups = NULL,
  domain_reference = c("subset", "all"),
  estimation_method = c("bootstrap_mc", "two_stage"),
  certainty_thresholds = c(0.8, 0.9, 0.95),
  pc_pairs = NULL,
  max_pcs = 4,
  domain_mode = c("hull", "full"),
  hull_type = "alpha",
  alpha_value = NULL,
  hull_buffer = 0.05,
  use_parallel = FALSE,
  n_cores = NULL,
  uncertainty_type = "gaussian",
  occupancy_method = "radius",
  occupancy_radius = 1.5,
  progress_callback = NULL,
  verbose = TRUE
)
}
\arguments{
\item{pca_scores}{Data frame or matrix with PC scores}

\item{uncertainty}{Proportion of axis range for uncertainty radius}

\item{grid_resolution}{Number of grid cells along each axis}

\item{monte_carlo_iterations}{Number of Monte Carlo replicates}

\item{monte_carlo_iterations_bootstrap}{Optional number of Monte Carlo
replicates to use within each bootstrap replicate. If NULL (default), a
uses
the value of \code{monte_carlo_iterations}.}

\item{bootstrap_iterations}{Number of bootstrap resamples}

\item{bootstrap_sample_size}{Optional subsample size for bootstrap iterations.
If NULL (default), uses full dataset. Values <= 1 are treated as fractions
(e.g., 0.5 = 50% of data). Values > 1 are treated as absolute counts.
Useful for comparing datasets with different sample sizes by normalizing
to the smallest dataset size.}

\item{bootstrap_progress_every}{Print a progress message every N bootstrap
iterations when \code{verbose = TRUE}. Also used for \code{progress_callback}
updates (e.g., in Shiny). Set to a larger number to reduce console output.}

\item{group_column}{Optional column name in \code{pca_scores} used to filter
specimens into groups for analysis. If NULL (default), uses all rows.}

\item{groups}{Optional vector of group values to include (matched against
\code{pca_scores[[group_column]]}). If NULL (default), includes all non-NA
values in the chosen group column.}

\item{domain_reference}{Which data define the analysis domain (grid extent and
hull/bounding box) when group filtering is used. Use \code{"subset"} to
compute the domain from the filtered data (default), or \code{"all"} to
compute the domain from the full unfiltered dataset while still computing
occupancy/gaps from the filtered subset.}

\item{estimation_method}{Estimation strategy. \code{"bootstrap_mc"} (default)
integrates sampling and measurement uncertainty by running Monte Carlo
perturbations within each bootstrap replicate and averaging gap probability
across bootstraps. \code{"two_stage"} uses the legacy two-step approach
(Monte Carlo on full data, then bootstrap-based stability) for backward
comparability.}

\item{certainty_thresholds}{Gap certainty thresholds for polygon extraction}

\item{pc_pairs}{Optional matrix specifying PC pairs to analyze}

\item{max_pcs}{Maximum PC to include in automatic pair generation}

\item{domain_mode}{Analysis domain. Use "hull" to constrain analysis to the
(alpha/convex) hull of the observed points, or "full" to analyze the full
rectangular morphospace defined by the (buffered) PC axis ranges.}

\item{hull_type}{Type of hull for domain constraint}

\item{alpha_value}{Alpha parameter for alphahull}

\item{hull_buffer}{Proportional buffer to add around hull}

\item{use_parallel}{Use parallel processing}

\item{n_cores}{Number of cores for parallel processing}

\item{uncertainty_type}{Type of uncertainty model}

\item{occupancy_method}{Method to determine cell occupancy}

\item{occupancy_radius}{Radius for occupancy detection}

\item{progress_callback}{Optional function for progress updates}

\item{verbose}{Print progress messages}
}
\value{
List of class morphospace_gaps with results
}
\description{
Detect Morphospace Gaps with Uncertainty Quantification
}
\details{
The default method (\code{estimation_method = "bootstrap_mc"}) integrates
measurement and sampling uncertainty in a single procedure:
the dataset is resampled (with replacement) B times and for each resample a
Monte Carlo perturbation procedure is run. The resulting per-cell gap
probability matrices are averaged across bootstrap replicates.

The legacy method (\code{estimation_method = "two_stage"}) retains the older
two-step computation (full-data Monte Carlo + bootstrap-based stability) and
combines them as \code{gap_certainty = gap_probability * gap_stability}.
}
\examples{
\dontrun{
# Assuming pca_result from PCA() contains $x with PC scores
gaps <- detect_morphospace_gaps(
  pca_scores = pca_result$x,
  uncertainty = 0.05,
  grid_resolution = 150,
  monte_carlo_iterations = 100,
  bootstrap_iterations = 200,
  max_pcs = 3
)

# View summary
print(gaps$summary_table)

# Access results for PC1-PC2
pc1_pc2_gaps <- gaps$results$`PC1-PC2`
plot(pc1_pc2_gaps$gap_certainty)

# Compare datasets with different sample sizes
# E.g., cretaceous_ants has 50 specimens, extant_ants has 666
# Subsample extant_ants to 50 for fair comparison
gaps_cretaceous <- detect_morphospace_gaps(
  pca_scores = cretaceous_pca$x,
  bootstrap_sample_size = 50,  # Use all 50 specimens
  max_pcs = 3
)

gaps_extant <- detect_morphospace_gaps(
  pca_scores = extant_pca$x,
  bootstrap_sample_size = 50,  # Subsample to 50 from 666
  max_pcs = 3
)

# Now both analyses use same sample size for bootstrap
# enabling proper comparison of gap certainty patterns
}

}
